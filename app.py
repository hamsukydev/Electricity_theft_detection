import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.impute import SimpleImputer
from PIL import Image

st.title('Meter Theft Prediction App')
st.write("With the help of Advanced Metering Infrastructure (AMI) applications, we have gathered customer meter readings for testing purposes. Our Streamlit app facilitates the analysis of this data. It allows users to upload an Excel file containing meter information, which is then visualized through a pair plot. Leveraging trained machine learning models, users can input a customer's meter number, previous reading, and current reading in the sidebar. Upon clicking the 'Predict' button, the app utilizes the model to predict potential theft, displaying the results alongside the customer's meter number.")

image = Image.open('meter.png')
st.sidebar.image(image)

# Load the Excel file
uploaded_file = st.sidebar.file_uploader("Upload Excel File", type=["xls", "xlsx"])

if uploaded_file is not None:
    # Load the data from the Excel file
    df = pd.read_excel(uploaded_file)

    # Display the loaded data
    st.sidebar.write("## Uploaded Data")
    st.sidebar.dataframe(df)

    # Visualize the data with a pair plot
    st.sidebar.write("## Data Visualization")
    pair_plot = sns.pairplot(df, hue="Label", palette={0: 'green', 1: 'red'})
    st.pyplot(pair_plot)

    # Assume the Excel file has columns 'Meter_No', 'Previous_Reading', 'Current_Reading', 'Label' (1 for theft, 0 for non-theft)
    features = df[['Meter_No', 'Previous_Reading', 'Current_Reading']]
    labels = df['Label']

    # Handle missing previous readings
    features['Previous_Reading'] = features['Previous_Reading'].replace('-', pd.NA)
    features = features.astype({'Previous_Reading': 'float'})

    # Add a new feature to indicate missing previous readings
    features['Missing_Previous_Reading'] = features['Previous_Reading'].isna().astype(int)

    # Handle missing values using SimpleImputer
    imputer = SimpleImputer(strategy='mean')  # You can use other strategies like 'median', 'most_frequent', etc.
    features_imputed = imputer.fit_transform(features.drop('Meter_No', axis=1))  # Exclude 'Meter_No' from features during imputation

    # Split data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(features_imputed, labels, test_size=0.2, random_state=42)

    # Train a RandomForestClassifier
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # Display model evaluation metrics
    st.sidebar.write("## Model Evaluation Metrics")
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    st.sidebar.write("Classification Report:")
    st.sidebar.text(classification_report(y_test, y_pred))

    # Allow user to input meter number, previous, current readings for prediction in the sidebar
    st.sidebar.write("## User Input for Prediction")
    meter_no = st.sidebar.text_input("Enter Customer Meter Number:")
    prev_reading = st.sidebar.text_input("Enter Previous Reading (or leave blank if not available):")
    current_reading = st.sidebar.number_input("Enter Current Reading:")

    # Handle missing previous reading input
    if prev_reading == '':
        missing_prev_reading = 1
        prev_reading = None
    else:
        missing_prev_reading = 0
        prev_reading = float(prev_reading)

    # Add a "Predict" button in the sidebar
    if st.sidebar.button("Predict"):
        # Use the trained model for prediction
        input_data = [[prev_reading, current_reading, missing_prev_reading]]
        prediction_proba = model.predict_proba(input_data)[0]
        prediction_custom_threshold = (prediction_proba[1] > 0.5).astype(int)

        # Display the prediction along with the meter number
        st.write("## Prediction:")
        st.write(f"Meter Number: {meter_no}")
        st.write(f"Probability of Theft: {prediction_proba[1]*100:.2f}%")

        # Adjust the threshold
        custom_threshold = 0.6  # Set your desired threshold
        prediction_custom_threshold = (prediction_proba[1] > custom_threshold).astype(int)

        # Display prediction with adjusted threshold
        if prediction_custom_threshold == 1:
            st.write("Potential theft detected with adjusted threshold!")
        else:
            st.write("No theft detected with adjusted threshold.")

        st.write("The threshold in this context refers to a decision boundary for classifying the prediction into one of the two classes (potential theft or no theft). The threshold is applied to the probability scores generated by the model.")
